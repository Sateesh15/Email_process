const PDFDocument = require('pdfkit');
const fs = require('fs-extra');
const path = require('path');
const logger = require('../utils/logger');

class PDFGeneratorService {
  constructor() {
    this.outputDir = 'outputs';
  }

  async generateCandidatePDF(candidate) {
    try {
      logger.info(`Generating PDF summary for: ${candidate.name}`);

      // Ensure output directory exists
      await fs.ensureDir(this.outputDir);

      // Create PDF document
      const doc = new PDFDocument({ 
        size: 'A4', 
        margin: 50,
        info: {
          Title: `${candidate.name} - Resume Summary`,
          Author: 'HR Resume Processor',
          Subject: 'Candidate Resume Summary',
          Creator: 'HR Resume Processing System'
        }
      });

      // Generate filename
      const sanitizedName = candidate.name.replace(/[^a-zA-Z0-9]/g, '_');
      const filename = `${sanitizedName}_Summary_${Date.now()}.pdf`;
      const filePath = path.join(this.outputDir, filename);

      // Create write stream
      const stream = fs.createWriteStream(filePath);
      doc.pipe(stream);

      // Add content to PDF
      this.addHeader(doc, candidate);
      this.addBasicInfo(doc, candidate);
      this.addSkills(doc, candidate);

      if (candidate.additionalFields) {
        this.addAdditionalFields(doc, candidate.additionalFields);
      }

      this.addFooter(doc, candidate);

      // Finalize PDF
      doc.end();

      // Wait for file to be written
      await new Promise((resolve, reject) => {
        stream.on('finish', resolve);
        stream.on('error', reject);
      });

      logger.info(`PDF summary generated successfully: ${filename}`);

      return filePath;

    } catch (error) {
      logger.error(`Error generating PDF for ${candidate.name}:`, error);
      throw new Error(`Failed to generate PDF summary: ${error.message}`);
    }
  }

  addHeader(doc, candidate) {
    // Header background
    doc.rect(0, 0, doc.page.width, 100)
       .fill('#366092');

    // Reset to black text
    doc.fillColor('white');

    // Title
    doc.fontSize(24)
       .font('Helvetica-Bold')
       .text('CANDIDATE SUMMARY', 50, 30);

    // Subtitle
    doc.fontSize(12)
       .font('Helvetica')
       .text('Generated by HR Resume Processor', 50, 60);

    // Reset position and color
    doc.y = 120;
    doc.fillColor('black');
  }

  addBasicInfo(doc, candidate) {
    const y = doc.y;

    // Section header
    this.addSectionHeader(doc, 'PERSONAL INFORMATION');

    const leftColumn = 50;
    const rightColumn = 300;
    const rowHeight = 25;

    // Left column
    this.addInfoRow(doc, 'Full Name:', candidate.name || 'Not provided', leftColumn, doc.y);
    this.addInfoRow(doc, 'Email:', candidate.email || 'Not provided', leftColumn, doc.y + rowHeight);
    this.addInfoRow(doc, 'Phone:', candidate.phone || 'Not provided', leftColumn, doc.y + rowHeight * 2);

    // Right column
    doc.y = y + 40; // Reset y position for right column
    this.addInfoRow(doc, 'Experience:', candidate.experience || 'Not specified', rightColumn, doc.y);

    if (candidate.linkedinUrl) {
      this.addInfoRow(doc, 'LinkedIn:', 'View Profile', rightColumn, doc.y + rowHeight);

      // Add hyperlink
      doc.fillColor('blue')
         .text('View Profile', rightColumn + 60, doc.y, {
           link: candidate.linkedinUrl,
           underline: true
         });
      doc.fillColor('black');
    }

    // Move to next section
    doc.y += rowHeight * 4;
  }

  addSkills(doc, candidate) {
    this.addSectionHeader(doc, 'SKILLS & EXPERTISE');

    // Primary Skills
    if (candidate.primarySkills && candidate.primarySkills.length > 0) {
      doc.fontSize(12)
         .font('Helvetica-Bold')
         .text('Primary Skills:', 50, doc.y);

      doc.fontSize(11)
         .font('Helvetica')
         .text(candidate.primarySkills.join(' • '), 50, doc.y + 15, {
           width: 500,
           lineGap: 5
         });

      doc.y += 40;
    }

    // Secondary Skills
    if (candidate.secondarySkills && candidate.secondarySkills.length > 0) {
      doc.fontSize(12)
         .font('Helvetica-Bold')
         .text('Secondary Skills:', 50, doc.y);

      doc.fontSize(11)
         .font('Helvetica')
         .text(candidate.secondarySkills.join(' • '), 50, doc.y + 15, {
           width: 500,
           lineGap: 5
         });

      doc.y += 40;
    }
  }

  addAdditionalFields(doc, additionalFields) {
    this.addSectionHeader(doc, 'ADDITIONAL INFORMATION');

    const fields = [
      { label: 'Education', value: additionalFields.education },
      { label: 'Location', value: additionalFields.location },
      { label: 'Current Role', value: additionalFields.currentRole },
      { label: 'Summary', value: additionalFields.summary },
      { label: 'Certifications', value: Array.isArray(additionalFields.certifications) 
        ? additionalFields.certifications.join(', ') 
        : additionalFields.certifications },
      { label: 'Languages', value: Array.isArray(additionalFields.languages) 
        ? additionalFields.languages.join(', ') 
        : additionalFields.languages }
    ];

    fields.forEach(field => {
      if (field.value && field.value !== 'N/A') {
        this.addInfoRow(doc, `${field.label}:`, field.value, 50, doc.y);
        doc.y += 25;
      }
    });
  }

  addFooter(doc, candidate) {
    // Move to bottom of page
    const pageHeight = doc.page.height;
    doc.y = pageHeight - 100;

    // Footer line
    doc.moveTo(50, doc.y)
       .lineTo(doc.page.width - 50, doc.y)
       .stroke('#cccccc');

    doc.y += 10;

    // Footer content
    doc.fontSize(9)
       .font('Helvetica')
       .fillColor('#666666')
       .text(`Generated on: ${new Date().toLocaleDateString()}`, 50, doc.y);

    doc.text(`Original File: ${candidate.originalFileName || 'Unknown'}`, 200, doc.y);

    doc.text(`Candidate ID: ${candidate.id}`, 400, doc.y);

    // Page number (for multi-page documents)
    doc.text(`Page 1`, doc.page.width - 100, doc.y);
  }

  addSectionHeader(doc, title) {
    // Add some space
    doc.y += 20;

    // Section header background
    doc.rect(50, doc.y - 5, doc.page.width - 100, 25)
       .fill('#f8f9fa');

    // Section title
    doc.fillColor('#333333')
       .fontSize(14)
       .font('Helvetica-Bold')
       .text(title, 55, doc.y + 5);

    // Reset
    doc.fillColor('black');
    doc.y += 35;
  }

  addInfoRow(doc, label, value, x, y) {
    const labelWidth = 100;

    // Label
    doc.fontSize(11)
       .font('Helvetica-Bold')
       .fillColor('#555555')
       .text(label, x, y);

    // Value
    doc.font('Helvetica')
       .fillColor('black')
       .text(value || 'Not provided', x + labelWidth, y, {
         width: 400,
         ellipsis: true
       });
  }

  // Utility method to generate batch PDFs
  async generateBatchPDFs(candidates) {
    const results = [];
    const errors = [];

    for (const candidate of candidates) {
      try {
        const pdfPath = await this.generateCandidatePDF(candidate);
        results.push({
          candidateId: candidate.id,
          candidateName: candidate.name,
          pdfPath: pdfPath,
          status: 'success'
        });
      } catch (error) {
        errors.push({
          candidateId: candidate.id,
          candidateName: candidate.name,
          error: error.message,
          status: 'failed'
        });
      }
    }

    return { results, errors };
  }

  // Utility method to clean up old PDFs
  async cleanupOldPDFs(daysOld = 7) {
    try {
      const files = await fs.readdir(this.outputDir);
      const now = Date.now();
      const maxAge = daysOld * 24 * 60 * 60 * 1000; // Convert to milliseconds

      let deletedCount = 0;

      for (const file of files) {
        if (file.endsWith('.pdf')) {
          const filePath = path.join(this.outputDir, file);
          const stats = await fs.stat(filePath);

          if (now - stats.mtime.getTime() > maxAge) {
            await fs.remove(filePath);
            deletedCount++;
          }
        }
      }

      logger.info(`Cleaned up ${deletedCount} old PDF files`);
      return deletedCount;

    } catch (error) {
      logger.error('Error cleaning up old PDFs:', error);
      throw error;
    }
  }
}

module.exports = new PDFGeneratorService();